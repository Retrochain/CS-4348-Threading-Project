# CS-4348-Threading-Project
A project meant to simulate multithreading in Java


Following is a program that is supposed to emulate multithreading synchronization. The project is seperated into 3 files: Restaraunt, Waiter & Customer. The Restaraunt is the main file and it creates and runs the threads necessary for the program. It assigns each waiter a table and creates 3 waiter threads to execute. It also creates 40 customer threads to execute. It contains a Table class for all the names, type of food served, seats, queues, etc, and also contains a Shared class to hold all semaphores. The Waiter class is utilized by all waiter threads and it essentially creates a waiter that gets assigned a table and waits until a customer calls upon the waiter. Once called, the waiter takes their order (also recieves the customer ID), sends it to the kitchen, waits, serves it to the customer and then waits for the next customer. It then repeats these steps until all 40 customers are served, upon which it exits after cleaning the table. The Customer class is utilized by all customers and it creates a customer with all the necessary data, assignes a random table, where the customer stands in the queue for the table. If there are no customers on the table (or there is a spot available), the customer sits at the table. If the queue is full (size is bigger than 7), then it switches to another random table (if it has one) only if the line for that table is ALSO less than 7. Once seated, it calls the customer, waits for their order, eats it upon recieving it, leaves the seat, pays the bill and then leaves the restaraunt. Only 2 customers are allowed in and out at a time.

Unfortunately, this code is incomplete/not working properly. The waiter or customer threads do not end and have to be manually terminated (by killing the program), The customers signal the wrong waiters, the waiter is only able to serve the next customer after the first one leaves (aka it is a more serialized code rather than parallel), which means the customers never switch tables as they do not have to wait in a queue. The main issue seems to be due to a race condition formed by a lack of mutual exclusion. 

The project was run on IntelliJ IDE 2022.2.2 Community Edition. It uses JDK 17 and was tested entierly on my personal computer. 
